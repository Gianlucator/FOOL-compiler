senza classi:
- let
      int x = 4;
      int g(int x) x;
      int z(int x) x - 1;
      int f(int y, bool b, int w)
         let int k = 5; in g(z(k));
    in
      print(f(x, true, x));
- "6"

class in input method:
- class A {
    int b() 2;
  }
  class B {
    int aparam(A param) param.b();
  };
  let B obj = new B; A a = new A;
  in print(obj.aparam(a));
- "2"

sooca:
- class Area{
    int s() 1;
  }
  class Rectangle{
    int t() 2;
  };
  let Area p = new Area;
      Rectangle q = new Rectangle;
  in print(p.s() + q.t());
- "3"

classe singola dec:
- class Rectangle(int l1, int l2) {
    int area() l1 * l2;
    int getL1() l1;
    int getL2() l2;
    int scaleArea(int scaling) scaling * l1 * l2;
    int calcArea(int l1, int l2) l1 * l2;
  };

  let Rectangle r = new Rectangle(2, 4);
  in print(r.calcArea(3, 5));
- "15"

inheritance semplice:
- class A {
    int u() 1;
  }
  class B implements A {
    int s(int x) x + 1;
  };

  let A x = new B;
  in print(x.s(1));
- "2"

overriding:
- class A {
    int u() 2;
    int k() 5;
  }
  class B implements A{
    bool u() true;
    int s() 3;
    int k() 6;
  };

  let A x = new B ;
  in print(x.k());
- "6"

covarianza corr:
- class Parent(int a) {
    int f(int x) 2 * 2;
    int r(int y) 2 * y;
  }
  class Child implements Parent (int a) {
     int f(int x) 2 * x;
     int r(int y) 3 * y;
  };

  let int x = 4; Parent o = new Child(x);
  in o.f(x);
- ""

#Funziona: dà errore di tipo di parametro incompatibile
#covarianza err:
#- class Parent(int a) {
#    int f(int x) 2 * 2;
#    int r(int y) 2 * y;
#  }
#  class Child implements Parent (int a) {
#     bool f(int x) 2 * x;
#     int r(int y) 3 * y;
#  };
#
#  let bool x = 4; Parent o = new Child(x);
#  in o.f(x);
#- ""

#Funziona: dà errore di tipo di ritorno incompatibile
#controvarianza err:
#- class Parent(int a) {
#    int f(int x) 2 * 2;
#    int r(int y) 2 * y;
#  }
#  class Child implements Parent (int a) {
#     int f(int x) 2 * x;
#     int r(bool y) 3 * y;
#  };
#  let bool x = 4; Parent o = new Child(x); in o.r(x);
#- ""

#errore perché non riesce a trovare il parametro x definito in f di Child
covarianza errato 1:
- class Parent(int a) {
    Child f(int x) x;
  }
  class Child implements Parent (int a) {
    int f(int x) 2 * x;
  };
  let int x = 4; Parent o = new Child(x); in print(o.f(x));
- "8"

tipo di ritorno errato e override errato:
- class Parent(int a) {
    Child r(Child c) c.f(2) + a;
  }
  class Child implements Parent (int a) {
    int r(Child c) 2 * x;
  };

  let int x = 4;
  Child c = new Child(x);
  Parent o = new Child(x); in o.r(c);
- ""

covarianza errato 2:
- class Parent(int a) {
    Child p(Child c) c.f(2);
  }
  class Child implements Parent (int a) {
    Child p(Child c) 2 * x;
  };

  let int x = 4; Parent o = new Child(x); in o.f(x);
- ""

#########TEST GIANLUCA


class in input method2:
- class A {
    int afun() 2;
  }
  class B(int p) {
    int aparam(A param) p * param.afun();
  };
  let B obj = new B(5); A a = new A;
  in print(obj.aparam(a));
- "10"

class in input method2:
- class A {
    int afun() 2;
  }
  class B(int p) {
    int aparam(A param) p * param.afun();
  };
  let B obj = new B(5); A a = new A;
  in print(obj.aparam(a));
- "10"

Costruttore ereditato test 1:
- class A(int a, int b) {
    int getA() a;
    int getB() b;
  }
  class B implements A (int c){
    int getC() c;
  };
  let B b = new B(1, 2, 3);
  in print(b.getC());
- "3"


Costruttore ereditato test 2:
- class A(int a, int b) {
    int getA() a;
    int getB() b;
  }
  class B implements A (int a, int b, int c){
    int getC() c;
  };
  let B b = new B(1, 2, 3);
  in print(b.getC());
- "3"

Superclass getter:
- class A(int a, int b) {
    int getA() a;
    int getB() b;
  }
  class B implements A (int c){
    int getter() this.getA();
  };
  let B b = new B(1, 2, 3);
  in print(b.getter());
- "1"  

##########FINE TEST GIANLUCA

covarianza errato 5:
- class GranParent(int a) {
      Parent p(Parent o) o;
  }

  class Parent implements GrandParent(int a){
      GrandParent p(GrandParent c) c;
  };

  let int x = 4; Parent o = new Parent(x); in o.p(x);
- ""

covarianza corr:
- class GranParent(int a) {
    Parent p(Parent o) o;
  }

  class Parent implements GrandParent(int a){
    Child p(Child c) c;
  }

  class Child implements GrandParent(int x){
    int f(int x) 2 * x;
  };

  let
  int x = 4;
  Child c = new Child(x);
  Parent o = new Parent(x);
  in o.p(c);
- ""












